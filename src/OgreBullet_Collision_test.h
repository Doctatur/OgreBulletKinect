/*
 -----------------------------------------------------------------------------
 Filename:    OgreBullet_Collision_test.h
 -----------------------------------------------------------------------------
 
 This source file is generated by the Ogre AppWizard. 
 
 Check out: http://conglomerate.berlios.de/wiki/doku.php?id=ogrewizards
 
 Based on the Example Framework for OGRE
 (Object-oriented Graphics Rendering Engine)
 
 Copyright (c) 2000-2007 The OGRE Team
 For the latest info, see http://www.ogre3d.org/
 
 You may use this sample code for anything you like, it is not covered by the
 LGPL like the rest of the OGRE engine.
 -----------------------------------------------------------------------------
 */
 #ifndef __OgreBullet_Collision_test_h_
 #define __OgreBullet_Collision_test_h_
 
 #include "OIS.h"
 #include "SdkTrays.h"
 #include "ExampleApplication.h"
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 #include "../res/resource.h"
 #endif

 #include "SinbadCharacterController.h"
 #include "OgreBulletDynamicsRigidBody.h"				 // for OgreBullet
 #include "Shapes/OgreBulletCollisionsStaticPlaneShape.h" // for static planes
 #include "Shapes/OgreBulletCollisionsSphereShape.h"		 // for Boxes
 #include "Shapes/OgreBulletCollisionsBoxShape.h"		 // for Boxes
 
// make a cube, no cube primiatives in ogre
// yanked from betajaen
//http://www.ogre3d.org/forums/viewtopic.php?p=301318&sid=ce193664e1d3d7c4af509e6f4e2718c6
ManualObject* createCubeMesh(Ogre::String name, Ogre::String matName) {

   ManualObject* cube = new ManualObject(name);

   cube->begin(matName);

   cube->position(0.5,-0.5,1.0);cube->normal(0.408248,-0.816497,0.408248);cube->textureCoord(1,0);
   cube->position(-0.5,-0.5,0.0);cube->normal(-0.408248,-0.816497,-0.408248);cube->textureCoord(0,1);
   cube->position(0.5,-0.5,0.0);cube->normal(0.666667,-0.333333,-0.666667);cube->textureCoord(1,1);
   cube->position(-0.5,-0.5,1.0);cube->normal(-0.666667,-0.333333,0.666667);cube->textureCoord(0,0);
   cube->position(0.5,0.5,1.0);cube->normal(0.666667,0.333333,0.666667);cube->textureCoord(1,0);
   cube->position(-0.5,-0.5,1.0);cube->normal(-0.666667,-0.333333,0.666667);cube->textureCoord(0,1);
   cube->position(0.5,-0.5,1.0);cube->normal(0.408248,-0.816497,0.408248);cube->textureCoord(1,1);
   cube->position(-0.5,0.5,1.0);cube->normal(-0.408248,0.816497,0.408248);cube->textureCoord(0,0);
   cube->position(-0.5,0.5,0.0);cube->normal(-0.666667,0.333333,-0.666667);cube->textureCoord(0,1);
   cube->position(-0.5,-0.5,0.0);cube->normal(-0.408248,-0.816497,-0.408248);cube->textureCoord(1,1);
   cube->position(-0.5,-0.5,1.0);cube->normal(-0.666667,-0.333333,0.666667);cube->textureCoord(1,0);
   cube->position(0.5,-0.5,0.0);cube->normal(0.666667,-0.333333,-0.666667);cube->textureCoord(0,1);
   cube->position(0.5,0.5,0.0);cube->normal(0.408248,0.816497,-0.408248);cube->textureCoord(1,1);
   cube->position(0.5,-0.5,1.0);cube->normal(0.408248,-0.816497,0.408248);cube->textureCoord(0,0);
   cube->position(0.5,-0.5,0.0);cube->normal(0.666667,-0.333333,-0.666667);cube->textureCoord(1,0);
   cube->position(-0.5,-0.5,0.0);cube->normal(-0.408248,-0.816497,-0.408248);cube->textureCoord(0,0);
   cube->position(-0.5,0.5,1.0);cube->normal(-0.408248,0.816497,0.408248);cube->textureCoord(1,0);
   cube->position(0.5,0.5,0.0);cube->normal(0.408248,0.816497,-0.408248);cube->textureCoord(0,1);
   cube->position(-0.5,0.5,0.0);cube->normal(-0.666667,0.333333,-0.666667);cube->textureCoord(1,1);
   cube->position(0.5,0.5,1.0);cube->normal(0.666667,0.333333,0.666667);cube->textureCoord(0,0);

   cube->triangle(0,1,2);      cube->triangle(3,1,0);
   cube->triangle(4,5,6);      cube->triangle(4,7,5);
   cube->triangle(8,9,10);      cube->triangle(10,7,8);
   cube->triangle(4,11,12);   cube->triangle(4,13,11);
   cube->triangle(14,8,12);   cube->triangle(14,15,8);
   cube->triangle(16,17,18);   cube->triangle(16,19,17);
   cube->end();

   return cube;
}

 // this pattern updates the scenenode position when it changes within the bullet simulation
// taken from BulletMotionState docs page24
class MyMotionState : public btMotionState {
public:
    MyMotionState(const btTransform &initialpos, Ogre::SceneNode *node) {
        mVisibleobj = node;
        mPos1 = initialpos;
    }
    virtual ~MyMotionState() {    }
    void setNode(Ogre::SceneNode *node) {
        mVisibleobj = node;
    }
    virtual void getWorldTransform(btTransform &worldTrans) const {
        worldTrans = mPos1;
    }
    virtual void setWorldTransform(const btTransform &worldTrans) {
        if(NULL == mVisibleobj) return; // silently return before we set a node
        btQuaternion rot = worldTrans.getRotation();
        mVisibleobj->setOrientation(rot.w(), rot.x(), rot.y(), rot.z());
        btVector3 pos = worldTrans.getOrigin();
        // TODO **** XXX need to fix this up such that it renders properly since this doesnt know the scale of the node
        // also the getCube function returns a cube that isnt centered on Z
        mVisibleobj->setPosition(pos.x(), pos.y()+5, pos.z()-5);
    }
protected:
    Ogre::SceneNode *mVisibleobj;
    btTransform mPos1;
};

 class OgreBullet_Collision_testFrameListener : public ExampleFrameListener
 {
 private:
        SceneManager* mSceneMgr; 
		SceneNode *boxNode;
		//// OgreBullet World
 		OgreBulletDynamics::DynamicsWorld *mWorld;	
 		OgreBulletCollisions::DebugDrawer *debugDrawer;
 		std::deque<OgreBulletDynamics::RigidBody *>         mBodies;
 		std::deque<OgreBulletCollisions::CollisionShape *>  mShapes;
		int mNumEntitiesInstanced;

		//kinect
		SinbadCharacterController* mChara;
		Ogre::OverlayElement* mDepthPanel;
		
		//bullet
		btDefaultCollisionConfiguration* collisionConfiguration;
		btCollisionDispatcher* dispatcher;
		btBroadphaseInterface* overlappingPairCache;
		btSequentialImpulseConstraintSolver* solver;
		btDiscreteDynamicsWorld* dynamicsWorld;
		btCollisionShape* groundShape;
		btAlignedObjectArray<btCollisionShape*> collisionShapes;

 public:
	OgreBullet_Collision_testFrameListener( SceneManager *sceneMgr, 
 												RenderWindow* win, 
 												Camera* cam,
 												Vector3 &gravityVector,
 												AxisAlignedBox &bounds)
												 : ExampleFrameListener(win, cam),
												   mSceneMgr(sceneMgr)
 	{
		setupSceneObject(sceneMgr);
		createOgreBulletSim(sceneMgr,win,cam,gravityVector,bounds);
		createBulletSim();
		createKinectCharater();
	}
	
	//create OgreBullet simulator
	void createOgreBulletSim(SceneManager *sceneMgr, RenderWindow* win, Camera* cam,Vector3 &gravityVector,AxisAlignedBox &bounds)
	{
		// Start Bullet
 		mWorld = new OgreBulletDynamics::DynamicsWorld(mSceneMgr, bounds, gravityVector);
 
 		// add Debug info display tool
 		debugDrawer = new OgreBulletCollisions::DebugDrawer();
 		debugDrawer->setDrawWireframe(true);	// we want to see the Bullet containers
 
 		mWorld->setDebugDrawer(debugDrawer);
 		mWorld->setShowDebugShapes(true);		// enable it if you want to see the Bullet containers
 		SceneNode *node = mSceneMgr->getRootSceneNode()->createChildSceneNode("debugDrawer", Ogre::Vector3::ZERO);
 		node->attachObject(static_cast <SimpleRenderable *> (debugDrawer));

		// Define a floor plane mesh
 		Entity *ent;
		Plane p;
		p.normal = Vector3(0,1,0); p.d = 0;
		MeshManager::getSingleton().createPlane("FloorPlane", 
														ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
														p, 200000, 200000, 20, 20, true, 1, 9000, 9000, 
														Vector3::UNIT_Z);
		// Create an entity (the floor)
		ent = mSceneMgr->createEntity("floor", "FloorPlane");
 		ent->setMaterialName("Examples/BumpyMetal");
		mSceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(ent);
 
 		// add collision detection to it
 		OgreBulletCollisions::CollisionShape *Shape;
 		Shape = new OgreBulletCollisions::StaticPlaneCollisionShape(Ogre::Vector3(0,1,0), 0); // (normal vector, distance)
 		// a body is needed for the shape
 		OgreBulletDynamics::RigidBody *defaultPlaneBody = new OgreBulletDynamics::RigidBody("BasePlane",mWorld);
 		defaultPlaneBody->setStaticShape(Shape, 0.1, 0.8);// (shape, restitution, friction)
 		// push the created objects to the deques
 		mShapes.push_back(Shape);
 		mBodies.push_back(defaultPlaneBody);
	}
		
	//create Bullet simulator
	void createBulletSim(void) 
	{
         ///collision configuration contains default setup for memory, collision setup. Advanced users can create their own configuration.
         collisionConfiguration = new btDefaultCollisionConfiguration();

         ///use the default collision dispatcher. For parallel processing you can use a diffent dispatcher (see Extras/BulletMultiThreaded)
         dispatcher = new   btCollisionDispatcher(collisionConfiguration);

         ///btDbvtBroadphase is a good general purpose broadphase. You can also try out btAxis3Sweep.
         overlappingPairCache = new btDbvtBroadphase();

         ///the default constraint solver. For parallel processing you can use a different solver (see Extras/BulletMultiThreaded)
         solver = new btSequentialImpulseConstraintSolver;

         dynamicsWorld = new btDiscreteDynamicsWorld(dispatcher,overlappingPairCache,solver,collisionConfiguration);
         dynamicsWorld->setGravity(btVector3(0,-10,0));

		 //dynamicsWorld = mWorld->getBulletDynamicsWorld();
         ///create a few basic rigid bodies
         // start with ground plane, 1500, 1500
         btCollisionShape* groundShape = new btBoxShape(btVector3(btScalar(1500.),btScalar(1.),btScalar(1500.)));

         collisionShapes.push_back(groundShape);

         btTransform groundTransform;
         groundTransform.setIdentity();
         groundTransform.setOrigin(btVector3(0,-2,0));

         {
            btScalar mass(0.);

            //rigidbody is dynamic if and only if mass is non zero, otherwise static
            bool isDynamic = (mass != 0.f);

            btVector3 localInertia(0,0,0);
            if (isDynamic)
               groundShape->calculateLocalInertia(mass,localInertia);

            // lathe - this plane isnt going to be moving so i dont care about setting the motion state
            //using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
            btDefaultMotionState* myMotionState = new btDefaultMotionState(groundTransform);
            btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,groundShape,localInertia);
            btRigidBody* body = new btRigidBody(rbInfo);

            //add the body to the dynamics world
            dynamicsWorld->addRigidBody(body);
         }


         {
            //create a dynamic rigidbody

            btCollisionShape* colShape = new btBoxShape(btVector3(1,1,1));
  //          btCollisionShape* colShape = new btSphereShape(btScalar(1.));
            collisionShapes.push_back(colShape);

            /// Create Dynamic Objects
            btTransform startTransform;
            startTransform.setIdentity();

            btScalar   mass(1.f);

            //rigidbody is dynamic if and only if mass is non zero, otherwise static
            bool isDynamic = (mass != 0.f);

            btVector3 localInertia(0,0,-1.0);
            if (isDynamic)
               colShape->calculateLocalInertia(mass,localInertia);

               startTransform.setOrigin(btVector3(0,250,0));
               // *** give it a slight twist so it bouncees more interesting
               startTransform.setRotation(btQuaternion(btVector3(1.0, 1.0, 0.0), 0.6));

               //using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
               //btDefaultMotionState* myMotionState = new btDefaultMotionState(startTransform);
               MyMotionState* motionState = new MyMotionState(startTransform, boxNode);
               btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,motionState,colShape,localInertia);
               btRigidBody* body = new btRigidBody(rbInfo);

               dynamicsWorld->addRigidBody(body);
         }
    }
    void setupSceneObject(SceneManager *sceneMgr)
    {
 		mMoveSpeed = 50;	// defined in ExampleFrameListener
		mSceneMgr = sceneMgr;
		mNumEntitiesInstanced = 0; // how many shapes are created

		// make a cube to bounce around
		Entity *ent;
		ManualObject *cmo = createCubeMesh("manual", "");
		cmo->convertToMesh("cube");
		ent = mSceneMgr->createEntity("Cube", "cube.mesh");
		ent->setCastShadows(true);
		boxNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
		boxNode->attachObject(ent);
		boxNode->setScale(Vector3(0.1,0.1,0.1)); // for some reason converttomesh multiplied dimensions by 10
	}
	void createKinectCharater(void)
	{
		// create our character controller
		mChara = new SinbadCharacterController(mCamera,mWorld,dynamicsWorld,mBodies,mShapes);

		// create the kinect depth image material
		const std::string colorTextureName        = "KinectColorTexture";
		const std::string depthTextureName        = "KinectDepthTexture";
		const std::string coloredDepthTextureName = "KinectColoredDepthTexture";

		SetupDepthMaterial();
		//createTexture(colorTextureName, depthTextureName);
		//createColoredDepthTexture(coloredDepthTextureName);
		//createKinectOverlay(colorTextureName, depthTextureName, coloredDepthTextureName);	
	}

	void SetupDepthMaterial()
	{
		Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
		Ogre::Overlay* overlay = overlayManager.create("MyDepthOverlay");

		// Create the texture
		TexturePtr texture = TextureManager::getSingleton().createManual(
				"MyDepthTexture", // name
				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
				TEX_TYPE_2D,      // type
				m_Width, m_Height,// width & height
				0,                // number of mipmaps
				PF_BYTE_BGRA,     // pixel format
				TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);

		
		// Create a material using the texture
		const std::string materialName = "DepthTextureMaterial";
		Ogre::MaterialPtr material = MaterialManager::getSingleton().create(
				"DepthTextureMaterial", // name
				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
		
		material->getTechnique(0)->getPass(0)->createTextureUnitState("MyDepthTexture");
		//material->getTechnique(0)->getPass(0)->setSceneBlending(SBT_TRANSPARENT_ALPHA);

		//Create Panel
		Ogre::PanelOverlayElement* panel = static_cast<Ogre::PanelOverlayElement*>(overlayManager.createOverlayElement("Panel", "MyDepthPanel"));
		panel->setMetricsMode(Ogre::GMM_RELATIVE);
		panel->setMaterialName(materialName);
		panel->setWidth(0.5);
		panel->setHeight(0.5*m_Height/m_Width);
		//panel->setDimensions(m_Width, m_Height);
		//panel->setHorizontalAlignment(GHA_RIGHT);
		//panel->setVerticalAlignment(GVA_BOTTOM);
		//panel->setLeft(-panel->getWidth());
		//panel->setTop(-panel->getHeight());
		panel->setPosition(0.0f, 0.0f);
		overlay->add2D(panel);		
		overlay->setZOrder(300);
		overlay->show(); 
	}

	void createTexture(const std::string& colorTextureName, const std::string& depthTextureName)
	{
		TexturePtr mColorTexture = TextureManager::getSingleton().createManual(
			colorTextureName, 
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
			TEX_TYPE_2D, 
			m_Width, 
			m_Height, 
			0,
			PF_BYTE_BGRA, 
			TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);

		TexturePtr mDepthTexture = TextureManager::getSingleton().createManual(
			depthTextureName, 
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
			TEX_TYPE_2D, 
			m_Width, 
			m_Height, 
			0,
			PF_BYTE_BGRA, 
			TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);
	}

	void createColoredDepthTexture(const std::string& coloredDepthTextureName)
	{
		TexturePtr mColoredDepthTexture = TextureManager::getSingleton().createManual(
			coloredDepthTextureName, 
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
			TEX_TYPE_2D, 
			m_Width, 
			m_Height, 
			0,
			PF_BYTE_BGRA, 
			TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);
	}

	//kinect image overlay
	void createKinectOverlay(const std::string& colorTextureName, const std::string& depthTextureName, const std::string& coloredDepthTextureName)
	{
		//Create Color Overlay
		{
			//Create Overlay
			Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
			Ogre::Overlay* overlay = overlayManager.create("KinectColorOverlay");

			//Create Material
			const std::string materialName = "KinectColorMaterial";
			Ogre::MaterialPtr material = MaterialManager::getSingleton().create(materialName, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
			material->getTechnique(0)->getPass(0)->setLightingEnabled(false);
			material->getTechnique(0)->getPass(0)->setDepthWriteEnabled(false);
			material->getTechnique(0)->getPass(0)->createTextureUnitState(colorTextureName);

			//Create Panel
			Ogre::PanelOverlayElement* panel = static_cast<Ogre::PanelOverlayElement*>(overlayManager.createOverlayElement("Panel", "KinectColorPanel"));
			panel->setMetricsMode(Ogre::GMM_PIXELS);
			panel->setMaterialName(materialName);
			panel->setWidth(1);
			panel->setHeight(1*m_Height/m_Width);
			//panel->setDimensions(m_Width, m_Height);
			panel->setPosition(640.0f, 0.0f);
			overlay->add2D(panel);		
			overlay->setZOrder(300);
			//overlay->show(); 
		}

		//Create Depth Overlay
		{
			//Create Overlay
			Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
			Ogre::Overlay* overlay = overlayManager.create("KinectDepthOverlay");

			//Create Material
			const std::string materialName = "KinectDepthMaterial";
			Ogre::MaterialPtr material = MaterialManager::getSingleton().create(materialName, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
			material->getTechnique(0)->getPass(0)->setLightingEnabled(false);
			material->getTechnique(0)->getPass(0)->setDepthWriteEnabled(false);
			material->getTechnique(0)->getPass(0)->setAlphaRejectSettings(CMPF_GREATER, 127);

			material->getTechnique(0)->getPass(0)->createTextureUnitState(depthTextureName);
			material->getTechnique(0)->getPass(0)->setVertexProgram("Ogre/Compositor/StdQuad_vp");
			//material->getTechnique(0)->getPass(0)->setFragmentProgram("KinectDepth");

			//Create Panel
			Ogre::PanelOverlayElement* panel = static_cast<Ogre::PanelOverlayElement*>(overlayManager.createOverlayElement("Panel", "KinectDepthPanel"));
			panel->setMetricsMode(Ogre::GMM_PIXELS);
			panel->setMaterialName(materialName);
			panel->setWidth(1);
			panel->setHeight(1*m_Height/m_Width);
			//panel->setDimensions(m_Width, m_Height);
			panel->setPosition((float)640.0f, 0.0f);
			overlay->add2D(panel);		
			overlay->setZOrder(310);
			//overlay->show();
		}

		//Create Colored Depth Overlay
		{
			//Create Overlay
			Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
			Ogre::Overlay* overlay = overlayManager.create("KinectColoredDepthOverlay");

			//Create Material
			const std::string materialName = "KinectColoredDepthMaterial";
			Ogre::MaterialPtr material = MaterialManager::getSingleton().create(materialName, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
			material->getTechnique(0)->getPass(0)->setLightingEnabled(false);
			material->getTechnique(0)->getPass(0)->setDepthWriteEnabled(false);
			material->getTechnique(0)->getPass(0)->createTextureUnitState(coloredDepthTextureName);

			//Create Panel
			Ogre::PanelOverlayElement* panel = static_cast<Ogre::PanelOverlayElement*>(overlayManager.createOverlayElement("Panel", "KinectColoredDepthPanel"));
			panel->setMetricsMode(Ogre::GMM_PIXELS);
			panel->setMaterialName(materialName);
			//panel->setWidth(1);
			//panel->setHeight(1*m_Height/m_Width);
			panel->setDimensions(m_Width, m_Height);
			panel->setPosition((float)0.0f, 0.0f);
			overlay->add2D(panel);		
			overlay->setZOrder(320);
			//overlay->show();
		}
	}
 	~OgreBullet_Collision_testFrameListener(){
 		// OgreBullet physic delete - RigidBodies
 		std::deque<OgreBulletDynamics::RigidBody *>::iterator itBody = mBodies.begin();
 		while (mBodies.end() != itBody)
 		{   
 			delete *itBody; 
 			++itBody;
 		}	
 		// OgreBullet physic delete - Shapes
 		std::deque<OgreBulletCollisions::CollisionShape *>::iterator itShape = mShapes.begin();
 		while (mShapes.end() != itShape)
 		{   
 			delete *itShape; 
 			++itShape;
 		}
 		mBodies.clear();
 		mShapes.clear();
 		delete mWorld->getDebugDrawer();
 		mWorld->setDebugDrawer(0);
 		delete mWorld;
 	}

 	bool frameStarted(const FrameEvent& evt)
 	{
 		bool ret = ExampleFrameListener::frameStarted(evt);
 
 		mWorld->stepSimulation(evt.timeSinceLastFrame);	// update Bullet Physics animation
		//mChara->UpdateDepthTexture();
		mChara->addTime(evt.timeSinceLastFrame);
        // update physics simulation
        dynamicsWorld->stepSimulation(evt.timeSinceLastFrame,50);

 		return ret;
 	}
 
 	bool frameEnded(const FrameEvent& evt)
 	{
 		bool ret = ExampleFrameListener::frameEnded(evt);
 
 		mWorld->stepSimulation(evt.timeSinceLastFrame);	// update Bullet Physics animation
 
 		return ret;
 	}
	
	//create cube rige in bulllet world
 	virtual bool processUnbufferedKeyInput(const FrameEvent& evt)
 	{
 		bool ret = ExampleFrameListener::processUnbufferedKeyInput(evt);
 
 		// create and throw a box if 'B' is pressed
 		if(mKeyboard->isKeyDown(OIS::KC_B) && mTimeUntilNextToggle <=0)
 		{
 			Vector3 size = Vector3::ZERO;	// size of the box
 			// starting position of the box
 			Vector3 position = (mCamera->getDerivedPosition() + mCamera->getDerivedDirection().normalisedCopy() * 10);
 
 			// create an ordinary, Ogre mesh with texture
 		    Entity *entity = mSceneMgr->createEntity(
 					"Box" + StringConverter::toString(mNumEntitiesInstanced),
 					"cube.mesh");			    
 			entity->setCastShadows(true);
 			// we need the bounding box of the box to be able to set the size of the Bullet-box
 			AxisAlignedBox boundingB = entity->getBoundingBox();
 			size = boundingB.getSize(); size /= 2.0f; // only the half needed
 			size *= 0.95f;	// Bullet margin is a bit bigger so we need a smaller size
 									// (Bullet 2.76 Physics SDK Manual page 18)
 			entity->setMaterialName("Examples/BumpyMetal");
 			SceneNode *node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
 			node->attachObject(entity);
 			node->scale(0.05f, 0.05f, 0.05f);	// the cube is too big for us
 			size *= 0.05f;						// don't forget to scale down the Bullet-box too
 
 			// after that create the Bullet shape with the calculated size
 			OgreBulletCollisions::BoxCollisionShape *sceneBoxShape = new OgreBulletCollisions::BoxCollisionShape(size);
 			// and the Bullet rigid body
 			OgreBulletDynamics::RigidBody *defaultBody = new OgreBulletDynamics::RigidBody(
 					"defaultBoxRigid" + StringConverter::toString(mNumEntitiesInstanced), 
 					mWorld);
 			defaultBody->setShape(	node,
 						sceneBoxShape,
 						0.6f,			// dynamic body restitution
 						0.6f,			// dynamic body friction
 						1.0f, 			// dynamic bodymass
 						position,		// starting position of the box
 						Quaternion(0,0,0,1));// orientation of the box
 		        mNumEntitiesInstanced++;				
 
 			// push the created objects to the dequese
 			mShapes.push_back(sceneBoxShape);
 			mBodies.push_back(defaultBody);				
 			mTimeUntilNextToggle = 0.5;
 		}
 		if(mKeyboard->isKeyDown(OIS::KC_C) && mTimeUntilNextToggle <=0)
 		{
 			Vector3 size = Vector3::ZERO;	// size of the box
 			// starting position of the box
 			Vector3 position = (mCamera->getDerivedPosition() + mCamera->getDerivedDirection().normalisedCopy() * 10);
 
 			// create an ordinary, Ogre mesh with texture
 		    Entity *entity = mSceneMgr->createEntity(
 					"Box" + StringConverter::toString(mNumEntitiesInstanced),
 					"cube.mesh");			    
 			entity->setCastShadows(true);
 			// we need the bounding box of the box to be able to set the size of the Bullet-box
 			AxisAlignedBox boundingB = entity->getBoundingBox();
 			size = boundingB.getSize(); size /= 2.0f; // only the half needed
 			size *= 0.95f;	// Bullet margin is a bit bigger so we need a smaller size
 									// (Bullet 2.76 Physics SDK Manual page 18)
 			entity->setMaterialName("Examples/BumpyMetal");
 			SceneNode *node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
 			node->attachObject(entity);
 			node->scale(0.05f, 0.05f, 0.05f);	// the cube is too big for us
 			size *= 0.05f;						// don't forget to scale down the Bullet-box too
 
 			// after that create the Bullet shape with the calculated size
 			OgreBulletCollisions::BoxCollisionShape *sceneBoxShape = new OgreBulletCollisions::BoxCollisionShape(size);
 			// and the Bullet rigid body
 			OgreBulletDynamics::RigidBody *defaultBody = new OgreBulletDynamics::RigidBody(
 					"defaultBoxRigid" + StringConverter::toString(mNumEntitiesInstanced), 
 					mWorld);
 			defaultBody->setShape(	node,
 						sceneBoxShape,
 						0.6f,			// dynamic body restitution
 						0.6f,			// dynamic body friction
 						1.0f, 			// dynamic bodymass
 						position,		// starting position of the box
 						Quaternion(0,0,0,1));// orientation of the box
 		        mNumEntitiesInstanced++;				
 
 			defaultBody->setLinearVelocity(
 						mCamera->getDerivedDirection().normalisedCopy() * 7.0f ); // shooting speed
 			// push the created objects to the dequese
 			mShapes.push_back(sceneBoxShape);
 			mBodies.push_back(defaultBody);				
 			mTimeUntilNextToggle = 0.5;
 		}

 		return ret;
 	}

 };
 
 
 class OgreBullet_Collision_testApp : public ExampleApplication
 {
 	public:
 		OgreBullet_Collision_testApp()
      {}
 
 	~OgreBullet_Collision_testApp()
 	{
 	}
 
 protected:
 
 	virtual void createCamera(void)
 	{
      // Create the camera
      mCamera = mSceneMgr->createCamera("PlayerCam");
 
      // Position it at 500 in Z direction
      mCamera->setPosition(Vector3(0,18,70));
      // Look back along -Z
      mCamera->lookAt(Vector3(0,0,-300));
      mCamera->setNearClipDistance(5);
 	}
 
 
    virtual bool configure(void)
    {
        // Show the configuration dialog and initialise the system
        // You can skip this and use root.restoreConfig() to load configuration
        // settings if you were sure there are valid ones saved in ogre.cfg
 		if(mRoot->showConfigDialog())
        {
            // If returned true, user clicked OK so initialise
            // Here we choose to let the system create a default rendering window by passing 'true'
            mWindow = mRoot->initialise(true);
			//mRoot->initialise(false, "Main Ogre Window");
			//NameValuePairList* misc = new NameValuePairList();
			//misc["externalWindowHandle"] = Handle.ToString();
			//mWindow = mRoot->createRenderWindow("Main RenderWindow", 800, 600, false, misc);
			//mWindowKinect = mRoot->createRenderWindow("Kinect RenderWindow", 800, 600, false, misc);
			// Let's add a nice window icon
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 			HWND hwnd;
 			mWindow->getCustomAttribute("WINDOW", (void*)&hwnd);
 			LONG iconID   = (LONG)LoadIcon( GetModuleHandle(0), MAKEINTRESOURCE(IDI_APPICON) );
 			SetClassLong( hwnd, GCL_HICON, iconID );
 #endif
            return true;
        }
        else
        {
            return false;
        }
    }
 
 
 	// Just override the mandatory create scene method
 	virtual void createScene(void)
 	{
  	  // Set ambient light
 	  mSceneMgr->setAmbientLight(ColourValue(0.5, 0.5, 0.5));
 
 	  // Create a light
 	  Light* l = mSceneMgr->createLight("MainLight");
 	  l->setPosition(20,80,50);
 	}
 
   // Create new frame listener
 	void createFrameListener(void)
 	{
      mFrameListener= new OgreBullet_Collision_testFrameListener( mSceneMgr, 
 								  mWindow, 
 								  mCamera,
                                  Vector3(0,-9.81,0), // gravity vector for Bullet
 								  AxisAlignedBox (Ogre::Vector3 (-10000, -10000, -10000), //aligned box for Bullet
  							          Ogre::Vector3 (10000,  10000,  10000)));
                                                     		  mRoot->addFrameListener(mFrameListener);
 	}

 protected:
    RenderWindow* mWindowKinect;
 };
 
 #endif // #ifndef __OgreBullet_Collision_test_h_
